-- THIS FILE WAS AUTOMATICALLY GENERATED BY AENEAS
-- [hello_aeneas]
import Aeneas
open Aeneas.Std Result Error
set_option linter.dupNamespace false
set_option linter.hashCommand false
set_option linter.unusedVariables false

namespace hello_aeneas

/- [hello_aeneas::choose]:
   Source: 'src/lib.rs', lines 1:0-3:1 -/
def choose
  {T : Type} (b : Bool) (x : T) (y : T) : Result (T × (T → (T × T))) :=
  if b
  then let back := fun ret => (ret, y)
       ok (x, back)
  else let back := fun ret => (x, ret)
       ok (y, back)

/- [hello_aeneas::mul2_add1]:
   Source: 'src/lib.rs', lines 5:0-7:1 -/
def mul2_add1 (x : U32) : Result U32 :=
  do
  let i ← x + x
  i + 1#u32

/- [hello_aeneas::mul2_add1_add]:
   Source: 'src/lib.rs', lines 9:0-11:1 -/
def mul2_add1_add (x : U32) (y : U32) : Result U32 :=
  do
  let i ← mul2_add1 x
  i + y

/- [hello_aeneas::incr]:
   Source: 'src/lib.rs', lines 13:0-15:1 -/
def incr (x : U32) : Result U32 :=
  x + 1#u32

/- [hello_aeneas::use_incr]:
   Source: 'src/lib.rs', lines 17:0-22:1 -/
def use_incr : Result Unit :=
  do
  let x ← incr 0#u32
  let x1 ← incr x
  let _ ← incr x1
  ok ()

/- [hello_aeneas::CList]
   Source: 'src/lib.rs', lines 26:0-29:1 -/
inductive CList (T : Type) where
| CCons : T → CList T → CList T
| CNil : CList T

/- [hello_aeneas::list_nth]:
   Source: 'src/lib.rs', lines 31:0-44:1 -/
def list_nth {T : Type} (l : CList T) (i : U32) : Result T :=
  match l with
  | CList.CCons x tl =>
    if i = 0#u32
    then ok x
    else do
         let i1 ← i - 1#u32
         list_nth tl i1
  | CList.CNil => fail panic
partial_fixpoint

/- [hello_aeneas::list_nth_mut]:
   Source: 'src/lib.rs', lines 46:0-59:1 -/
def list_nth_mut
  {T : Type} (l : CList T) (i : U32) : Result (T × (T → CList T)) :=
  match l with
  | CList.CCons x tl =>
    if i = 0#u32
    then let back := fun ret => CList.CCons ret tl
         ok (x, back)
    else
      do
      let i1 ← i - 1#u32
      let (x1, list_nth_mut_back) ← list_nth_mut tl i1
      let back := fun ret => let tl1 := list_nth_mut_back ret
                             CList.CCons x tl1
      ok (x1, back)
  | CList.CNil => fail panic
partial_fixpoint

/- [hello_aeneas::list_nth1]: loop 0:
   Source: 'src/lib.rs', lines 62:4-70:1 -/
def list_nth1_loop {T : Type} (l : CList T) (i : U32) : Result T :=
  match l with
  | CList.CCons x tl =>
    if i = 0#u32
    then ok x
    else do
         let i1 ← i - 1#u32
         list_nth1_loop tl i1
  | CList.CNil => fail panic
partial_fixpoint

/- [hello_aeneas::list_nth1]:
   Source: 'src/lib.rs', lines 61:0-70:1 -/
@[reducible]
def list_nth1 {T : Type} (l : CList T) (i : U32) : Result T :=
  list_nth1_loop l i

/- [hello_aeneas::i32_id]:
   Source: 'src/lib.rs', lines 72:0-74:1 -/
def i32_id (i : I32) : Result I32 :=
  if i = 0#i32
  then ok 0#i32
  else do
       let i1 ← i - 1#i32
       let i2 ← i32_id i1
       i2 + 1#i32
partial_fixpoint

/- [hello_aeneas::even]:
   Source: 'src/lib.rs', lines 76:0-78:1 -/
mutual def even (i : U32) : Result Bool :=
  if i = 0#u32
  then ok true
  else do
       let i1 ← i - 1#u32
       odd i1
partial_fixpoint

/- [hello_aeneas::odd]:
   Source: 'src/lib.rs', lines 80:0-82:1 -/
def odd (i : U32) : Result Bool :=
  if i = 0#u32
  then ok false
  else do
       let i1 ← i - 1#u32
       even i1
partial_fixpoint

end

/- Trait declaration: [hello_aeneas::Counter]
   Source: 'src/lib.rs', lines 86:0-88:1 -/
structure Counter (Self : Type) where
  incr : Self → Result (Usize × Self)

/- [hello_aeneas::{hello_aeneas::Counter for usize}::incr]:
   Source: 'src/lib.rs', lines 91:4-95:5 -/
def CounterUsize.incr (self : Usize) : Result (Usize × Usize) :=
  do
  let self1 ← self + 1#usize
  ok (self, self1)

/- Trait implementation: [hello_aeneas::{hello_aeneas::Counter for usize}]
   Source: 'src/lib.rs', lines 90:0-96:1 -/
@[reducible]
def CounterUsize : Counter Usize := {
  incr := CounterUsize.incr
}

/- [hello_aeneas::use_counter]:
   Source: 'src/lib.rs', lines 98:0-100:1 -/
def use_counter
  {T : Type} (CounterInst : Counter T) (cnt : T) : Result (Usize × T) :=
  CounterInst.incr cnt

/- [hello_aeneas::list_nth_mut1]: loop 0:
   Source: 'src/lib.rs', lines 105:4-113:1 -/
def list_nth_mut1_loop
  {T : Type} (l : CList T) (i : U32) : Result (T × (T → CList T)) :=
  match l with
  | CList.CCons x tl =>
    if i = 0#u32
    then let back := fun ret => CList.CCons ret tl
         ok (x, back)
    else
      do
      let i1 ← i - 1#u32
      let (t, back) ← list_nth_mut1_loop tl i1
      let back1 := fun ret => let tl1 := back ret
                              CList.CCons x tl1
      ok (t, back1)
  | CList.CNil => fail panic
partial_fixpoint

/- [hello_aeneas::list_nth_mut1]:
   Source: 'src/lib.rs', lines 104:0-113:1 -/
@[reducible]
def list_nth_mut1
  {T : Type} (l : CList T) (i : U32) : Result (T × (T → CList T)) :=
  list_nth_mut1_loop l i

/- [hello_aeneas::list_tail]: loop 0:
   Source: 'src/lib.rs', lines 116:4-118:5 -/
def list_tail_loop
  {T : Type} (l : CList T) : Result ((CList T) × (CList T → CList T)) :=
  match l with
  | CList.CCons t tl =>
    do
    let (c, back) ← list_tail_loop tl
    let back1 := fun ret => let tl1 := back ret
                            CList.CCons t tl1
    ok (c, back1)
  | CList.CNil => ok (CList.CNil, fun ret => ret)
partial_fixpoint

/- [hello_aeneas::list_tail]:
   Source: 'src/lib.rs', lines 115:0-120:1 -/
@[reducible]
def list_tail
  {T : Type} (l : CList T) : Result ((CList T) × (CList T → CList T)) :=
  list_tail_loop l

/- [hello_aeneas::append_in_place]:
   Source: 'src/lib.rs', lines 122:0-125:1 -/
def append_in_place
  {T : Type} (l0 : CList T) (l1 : CList T) : Result (CList T) :=
  do
  let (_, list_tail_back) ← list_tail l0
  ok (list_tail_back l1)

/- [hello_aeneas::reverse]: loop 0:
   Source: 'src/lib.rs', lines 129:4-133:5 -/
def reverse_loop {T : Type} (l : CList T) (out : CList T) : Result (CList T) :=
  match l with
  | CList.CCons hd tl => reverse_loop tl (CList.CCons hd out)
  | CList.CNil => ok out
partial_fixpoint

/- [hello_aeneas::reverse]:
   Source: 'src/lib.rs', lines 127:0-135:1 -/
@[reducible]
def reverse {T : Type} (l : CList T) : Result (CList T) :=
  reverse_loop l CList.CNil

/- [hello_aeneas::zero]: loop 0:
   Source: 'src/lib.rs', lines 144:4-147:5 -/
def zero_loop
  (x : alloc.vec.Vec U32) (i : Usize) : Result (alloc.vec.Vec U32) :=
  let i1 := alloc.vec.Vec.len x
  if i < i1
  then
    do
    let (_, index_mut_back) ←
      alloc.vec.Vec.index_mut (core.slice.index.SliceIndexUsizeSliceInst U32) x
        i
    let i2 ← i + 1#usize
    let x1 := index_mut_back 0#u32
    zero_loop x1 i2
  else ok x
partial_fixpoint

/- [hello_aeneas::zero]:
   Source: 'src/lib.rs', lines 142:0-148:1 -/
@[reducible]
def zero (x : alloc.vec.Vec U32) : Result (alloc.vec.Vec U32) :=
  zero_loop x 0#usize

/- [hello_aeneas::add_no_overflow]: loop 0:
   Source: 'src/lib.rs', lines 157:4-160:5 -/
def add_no_overflow_loop
  (x : alloc.vec.Vec U32) (y : alloc.vec.Vec U32) (i : Usize) :
  Result (alloc.vec.Vec U32)
  :=
  let i1 := alloc.vec.Vec.len x
  if i < i1
  then
    do
    let i2 ←
      alloc.vec.Vec.index (core.slice.index.SliceIndexUsizeSliceInst U32) y i
    let (i3, index_mut_back) ←
      alloc.vec.Vec.index_mut (core.slice.index.SliceIndexUsizeSliceInst U32) x
        i
    let i4 ← i3 + i2
    let i5 ← i + 1#usize
    let x1 := index_mut_back i4
    add_no_overflow_loop x1 y i5
  else ok x
partial_fixpoint

/- [hello_aeneas::add_no_overflow]:
   Source: 'src/lib.rs', lines 155:0-161:1 -/
@[reducible]
def add_no_overflow
  (x : alloc.vec.Vec U32) (y : alloc.vec.Vec U32) :
  Result (alloc.vec.Vec U32)
  :=
  add_no_overflow_loop x y 0#usize

/- [hello_aeneas::add_with_carry]: loop 0:
   Source: 'src/lib.rs', lines 170:4-177:5 -/
def add_with_carry_loop
  (x : alloc.vec.Vec U32) (y : alloc.vec.Vec U32) (c0 : U8) (i : Usize) :
  Result (U8 × (alloc.vec.Vec U32))
  :=
  let i1 := alloc.vec.Vec.len x
  if i < i1
  then
    do
    let i2 ←
      alloc.vec.Vec.index (core.slice.index.SliceIndexUsizeSliceInst U32) x i
    let i3 ← (↑(UScalar.cast .U32 c0) : Result U32)
    let (sum, c1) ←
      (↑(core.num.U32.overflowing_add i2 i3) : Result (U32 × Bool))
    let i4 ←
      alloc.vec.Vec.index (core.slice.index.SliceIndexUsizeSliceInst U32) y i
    let (sum1, c2) ←
      (↑(core.num.U32.overflowing_add sum i4) : Result (U32 × Bool))
    let i5 ← (↑(UScalar.cast_fromBool .U8 c1) : Result U8)
    let i6 ← (↑(UScalar.cast_fromBool .U8 c2) : Result U8)
    let c01 ← i5 + i6
    let (_, index_mut_back) ←
      alloc.vec.Vec.index_mut (core.slice.index.SliceIndexUsizeSliceInst U32) x
        i
    let i7 ← i + 1#usize
    let x1 := index_mut_back sum1
    add_with_carry_loop x1 y c01 i7
  else ok (c0, x)
partial_fixpoint

/- [hello_aeneas::add_with_carry]:
   Source: 'src/lib.rs', lines 166:0-179:1 -/
@[reducible]
def add_with_carry
  (x : alloc.vec.Vec U32) (y : alloc.vec.Vec U32) :
  Result (U8 × (alloc.vec.Vec U32))
  :=
  add_with_carry_loop x y 0#u8 0#usize

/- [hello_aeneas::max]:
   Source: 'src/lib.rs', lines 181:0-183:1 -/
def max (x : Usize) (y : Usize) : Result Usize :=
  if x > y
  then ok x
  else ok y

/- [hello_aeneas::get_or_zero]:
   Source: 'src/lib.rs', lines 185:0-187:1 -/
def get_or_zero (y : alloc.vec.Vec U32) (i : Usize) : Result U32 :=
  let i1 := alloc.vec.Vec.len y
  if i < i1
  then alloc.vec.Vec.index (core.slice.index.SliceIndexUsizeSliceInst U32) y i
  else ok 0#u32

/- [hello_aeneas::add]: loop 0:
   Source: 'src/lib.rs', lines 201:4-209:5 -/
def add_loop
  (x : alloc.vec.Vec U32) (y : alloc.vec.Vec U32) (max1 : Usize) (c0 : U8)
  (i : Usize) :
  Result (alloc.vec.Vec U32)
  :=
  if i < max1
  then
    do
    let yi ← get_or_zero y i
    let i1 ←
      alloc.vec.Vec.index (core.slice.index.SliceIndexUsizeSliceInst U32) x i
    let i2 ← (↑(UScalar.cast .U32 c0) : Result U32)
    let (sum, c1) ←
      (↑(core.num.U32.overflowing_add i1 i2) : Result (U32 × Bool))
    let (sum1, c2) ←
      (↑(core.num.U32.overflowing_add sum yi) : Result (U32 × Bool))
    let i3 ← (↑(UScalar.cast_fromBool .U8 c1) : Result U8)
    let i4 ← (↑(UScalar.cast_fromBool .U8 c2) : Result U8)
    let c01 ← i3 + i4
    let (_, index_mut_back) ←
      alloc.vec.Vec.index_mut (core.slice.index.SliceIndexUsizeSliceInst U32) x
        i
    let i5 ← i + 1#usize
    let x1 := index_mut_back sum1
    add_loop x1 y max1 c01 i5
  else
    if c0 != 0#u8
    then
      do
      let i1 ← (↑(UScalar.cast .U32 c0) : Result U32)
      alloc.vec.Vec.push x i1
    else ok x
partial_fixpoint

/- [hello_aeneas::add]:
   Source: 'src/lib.rs', lines 194:0-215:1 -/
def add
  (x : alloc.vec.Vec U32) (y : alloc.vec.Vec U32) :
  Result (alloc.vec.Vec U32)
  :=
  do
  let i := alloc.vec.Vec.len x
  let i1 := alloc.vec.Vec.len y
  let max1 ← max i i1
  let x1 ← alloc.vec.Vec.resize core.clone.CloneU32 x max1 0#u32
  add_loop x1 y max1 0#u8 0#usize

end hello_aeneas
